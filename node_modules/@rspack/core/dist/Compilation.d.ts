/// <reference types="node" />
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compilation.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
import * as tapable from "tapable";
import { Source } from "webpack-sources";
import type { ExternalObject, JsAssetInfo, JsCompilation, JsModule, JsRuntimeModule, JsStatsChunk, JsPathData, JsStatsWarning } from "@rspack/binding";
import { RspackOptionsNormalized, StatsOptions, OutputNormalized, StatsValue, RspackPluginInstance, Filename } from "./config";
import * as liteTapable from "./lite-tapable";
import { ContextModuleFactory } from "./ContextModuleFactory";
import ResolverFactory = require("./ResolverFactory");
import { Compiler } from "./Compiler";
import { Logger } from "./logging/Logger";
import { NormalModuleFactory } from "./NormalModuleFactory";
import { Stats } from "./Stats";
import { StatsFactory } from "./stats/StatsFactory";
import { StatsPrinter } from "./stats/StatsPrinter";
import MergeCaller from "./util/MergeCaller";
import { Chunk } from "./Chunk";
import { CodeGenerationResult, Module } from "./Module";
import { ChunkGraph } from "./ChunkGraph";
import { Entrypoint } from "./Entrypoint";
export type AssetInfo = Partial<JsAssetInfo> & Record<string, any>;
export type Assets = Record<string, Source>;
export interface Asset {
    name: string;
    source: Source;
    info: JsAssetInfo;
}
export type PathData = JsPathData;
export interface LogEntry {
    type: string;
    args: any[];
    time?: number;
    trace?: string[];
}
export interface CompilationParams {
    normalModuleFactory: NormalModuleFactory;
    contextModuleFactory: ContextModuleFactory;
}
export interface KnownCreateStatsOptionsContext {
    forToString?: boolean;
}
export interface ExecuteModuleArgument {
    codeGenerationResult: CodeGenerationResult;
    moduleObject: {
        id: string;
        exports: any;
        loaded: boolean;
        error?: Error;
    };
}
export interface ExecuteModuleContext {
    __webpack_require__: (id: string) => any;
}
type CreateStatsOptionsContext = KnownCreateStatsOptionsContext & Record<string, any>;
export declare class Compilation {
    #private;
    hooks: {
        processAssets: liteTapable.AsyncSeriesHook<Assets>;
        afterProcessAssets: liteTapable.SyncHook<Assets>;
        childCompiler: tapable.SyncHook<[Compiler, string, number]>;
        log: tapable.SyncBailHook<[string, LogEntry], true>;
        additionalAssets: any;
        optimizeModules: liteTapable.SyncBailHook<Iterable<Module>, void>;
        afterOptimizeModules: liteTapable.SyncHook<Iterable<Module>, void>;
        optimizeTree: liteTapable.AsyncSeriesHook<[
            Iterable<Chunk>,
            Iterable<Module>
        ]>;
        optimizeChunkModules: liteTapable.AsyncSeriesBailHook<[
            Iterable<Chunk>,
            Iterable<Module>
        ], void>;
        finishModules: liteTapable.AsyncSeriesHook<[Iterable<Module>], void>;
        chunkAsset: liteTapable.SyncHook<[Chunk, string], void>;
        processWarnings: tapable.SyncWaterfallHook<[Error[]]>;
        succeedModule: liteTapable.SyncHook<[Module], void>;
        stillValidModule: liteTapable.SyncHook<[Module], void>;
        statsFactory: tapable.SyncHook<[StatsFactory, StatsOptions], void>;
        statsPrinter: tapable.SyncHook<[StatsPrinter, StatsOptions], void>;
        buildModule: liteTapable.SyncHook<[Module]>;
        executeModule: liteTapable.SyncHook<[
            ExecuteModuleArgument,
            ExecuteModuleContext
        ]>;
        runtimeModule: liteTapable.SyncHook<[JsRuntimeModule, Chunk], void>;
        afterSeal: liteTapable.AsyncSeriesHook<[], void>;
    };
    options: RspackOptionsNormalized;
    outputOptions: OutputNormalized;
    compiler: Compiler;
    resolverFactory: ResolverFactory;
    inputFileSystem: any;
    logging: Map<string, LogEntry[]>;
    name?: string;
    childrenCounters: Record<string, number>;
    startTime?: number;
    endTime?: number;
    children: Compilation[];
    chunkGraph: ChunkGraph;
    fileSystemInfo: {
        createSnapshot(): null;
    };
    constructor(compiler: Compiler, inner: JsCompilation);
    get currentNormalModuleHooks(): {
        loader: tapable.SyncHook<[import("./config").LoaderContext<{}>], void, tapable.UnsetAdditionalOptions>;
        readResourceForScheme: any;
        readResource: tapable.HookMap<tapable.AsyncSeriesBailHook<[import("./config").LoaderContext<{}>], string | Buffer, tapable.UnsetAdditionalOptions>>;
    };
    get hash(): string | null;
    get fullHash(): string | null;
    /**
     * Get a map of all assets.
     *
     * Source: [assets](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L1008-L1009)
     */
    get assets(): Record<string, Source>;
    /**
     * Get a map of all entrypoints.
     */
    get entrypoints(): ReadonlyMap<string, Entrypoint>;
    getCache(name: string): import("./lib/CacheFacade");
    createStatsOptions(optionsOrPreset: StatsValue | undefined, context?: CreateStatsOptionsContext): StatsOptions;
    createStatsFactory(options: StatsOptions): StatsFactory;
    createStatsPrinter(options: StatsOptions): StatsPrinter;
    /**
     * Update an existing asset. Trying to update an asset that doesn't exist will throw an error.
     *
     * See: [Compilation.updateAsset](https://webpack.js.org/api/compilation-object/#updateasset)
     * Source: [updateAsset](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4320)
     *
     * FIXME: *AssetInfo* may be undefined in update fn for webpack impl, but still not implemented in rspack
     */
    updateAsset(filename: string, newSourceOrFunction: Source | ((source: Source) => Source), assetInfoUpdateOrFunction?: AssetInfo | ((assetInfo: AssetInfo) => AssetInfo)): void;
    /**
     * Emit an not existing asset. Trying to emit an asset that already exists will throw an error.
     *
     * See: [Compilation.emitAsset](https://webpack.js.org/api/compilation-object/#emitasset)
     * Source: [emitAsset](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4239)
     *
     * @param file - file name
     * @param source - asset source
     * @param assetInfo - extra asset information
     */
    emitAsset(filename: string, source: Source, assetInfo?: AssetInfo): void;
    deleteAsset(filename: string): void;
    renameAsset(filename: string, newFilename: string): void;
    /**
     * Get an array of Asset
     *
     * See: [Compilation.getAssets](https://webpack.js.org/api/compilation-object/#getassets)
     * Source: [getAssets](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4448)
     */
    getAssets(): Readonly<Asset>[];
    getAsset(name: string): Asset | void;
    pushDiagnostic(severity: "error" | "warning", title: string, message: string): void;
    __internal__pushNativeDiagnostics(diagnostics: ExternalObject<any>): void;
    get errors(): any;
    get warnings(): JsStatsWarning[];
    getPath(filename: Filename, data?: PathData): string;
    getPathWithInfo(filename: Filename, data?: PathData): import("@rspack/binding").PathWithInfo;
    getAssetPath(filename: Filename, data?: PathData): string;
    getAssetPathWithInfo(filename: Filename, data?: PathData): import("@rspack/binding").PathWithInfo;
    getLogger(name: string | (() => string)): Logger;
    fileDependencies: {
        [Symbol.iterator](): Generator<string, void, unknown>;
        has(dep: string): boolean;
        add: (dep: string) => void;
        addAll: (deps: Iterable<string>) => void;
    };
    contextDependencies: {
        [Symbol.iterator](): Generator<string, void, unknown>;
        has(dep: string): boolean;
        add: (dep: string) => void;
        addAll: (deps: Iterable<string>) => void;
    };
    missingDependencies: {
        [Symbol.iterator](): Generator<string, void, unknown>;
        has(dep: string): boolean;
        add: (dep: string) => void;
        addAll: (deps: Iterable<string>) => void;
    };
    buildDependencies: {
        [Symbol.iterator](): Generator<string, void, unknown>;
        has(dep: string): boolean;
        add: (dep: string) => void;
        addAll: (deps: Iterable<string>) => void;
    };
    get modules(): Module[];
    get chunks(): Chunk[];
    /**
     * Get the named chunks.
     *
     * Note: This is a proxy for webpack internal API, only method `get` is supported now.
     */
    get namedChunks(): Map<string, Readonly<Chunk>>;
    /**
     * Get the associated `modules` of an given chunk.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getAssociatedModules(chunk: JsStatsChunk): any[] | undefined;
    /**
     * Find a modules in an array.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__findJsModule(identifier: string, modules: Map<string, JsModule>): JsModule | undefined;
    /**
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getModules(): JsModule[];
    /**
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getChunks(): Chunk[];
    getStats(): Stats;
    createChildCompiler(name: string, outputOptions: OutputNormalized, plugins: RspackPluginInstance[]): Compiler;
    _rebuildModuleCaller: MergeCaller<[string, (err: Error, m: Module) => void]>;
    rebuildModule(m: Module, f: (err: Error, m: Module) => void): void;
    /**
     * Get the `Source` of a given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in the future.
     *
     * @internal
     */
    __internal__getAssetSource(filename: string): Source | void;
    /**
     * Set the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__setAssetSource(filename: string, source: Source): void;
    /**
     * Delete the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__deleteAssetSource(filename: string): void;
    /**
     * Get a list of asset filenames.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getAssetFilenames(): string[];
    /**
     * Test if an asset exists.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__hasAsset(name: string): boolean;
    __internal_getInner(): JsCompilation;
    seal(): void;
    unseal(): void;
    static PROCESS_ASSETS_STAGE_ADDITIONAL: number;
    static PROCESS_ASSETS_STAGE_PRE_PROCESS: number;
    static PROCESS_ASSETS_STAGE_DERIVED: number;
    static PROCESS_ASSETS_STAGE_ADDITIONS: number;
    static PROCESS_ASSETS_STAGE_NONE: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE: number;
    static PROCESS_ASSETS_STAGE_DEV_TOOLING: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE: number;
    static PROCESS_ASSETS_STAGE_SUMMARIZE: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_HASH: number;
    static PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER: number;
    static PROCESS_ASSETS_STAGE_ANALYSE: number;
    static PROCESS_ASSETS_STAGE_REPORT: number;
}
export {};
