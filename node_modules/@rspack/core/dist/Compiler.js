"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Compiler_instances, _Compiler_instance, _Compiler_initial, _Compiler_disabledHooks, _Compiler_nonSkippableRegisters, _Compiler_registers, _Compiler_moduleExecutionResultsMap, _Compiler_getInstance, _Compiler_updateNonSkippableRegisters, _Compiler_decorateJsTaps, _Compiler_createHookRegisterTaps, _Compiler_createHookMapRegisterTaps, _Compiler_build, _Compiler_createCompilation, _Compiler_resetThisCompilation, _Compiler_newCompilationParams;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const binding = __importStar(require("@rspack/binding"));
const index_1 = require("./index");
const fs_1 = __importDefault(require("fs"));
const tapable = __importStar(require("tapable"));
const liteTapable = __importStar(require("./lite-tapable"));
const tapable_1 = require("tapable");
const config_1 = require("./config");
const RuleSetCompiler_1 = require("./RuleSetCompiler");
const Stats_1 = require("./Stats");
const Compilation_1 = require("./Compilation");
const ContextModuleFactory_1 = require("./ContextModuleFactory");
const ResolverFactory = require("./ResolverFactory");
const ConcurrentCompilationError_1 = __importDefault(require("./error/ConcurrentCompilationError"));
const fileSystem_1 = require("./fileSystem");
const Cache = require("./lib/Cache");
const CacheFacade = require("./lib/CacheFacade");
const Logger_1 = require("./logging/Logger");
const NormalModuleFactory_1 = require("./NormalModuleFactory");
const bindingVersionCheck_1 = require("./util/bindingVersionCheck");
const Watching_1 = require("./Watching");
const builtin_plugin_1 = require("./builtin-plugin");
const defaults_1 = require("./config/defaults");
const assertNotNil_1 = require("./util/assertNotNil");
const RuntimeGlobals_1 = require("./RuntimeGlobals");
const HookWebpackError_1 = require("./lib/HookWebpackError");
const Module_1 = require("./Module");
const base_1 = require("./builtin-plugin/base");
const ExecuteModulePlugin_1 = __importDefault(require("./ExecuteModulePlugin"));
const Chunk_1 = require("./Chunk");
class Compiler {
    constructor(context, options) {
        _Compiler_instances.add(this);
        _Compiler_instance.set(this, void 0);
        this.webpack = index_1.rspack;
        // TODO: remove this after remove rebuild on the rust side.
        _Compiler_initial.set(this, true);
        _Compiler_disabledHooks.set(this, void 0);
        _Compiler_nonSkippableRegisters.set(this, void 0);
        _Compiler_registers.set(this, void 0);
        _Compiler_moduleExecutionResultsMap.set(this, void 0);
        this.outputFileSystem = fs_1.default;
        this.options = options;
        this.cache = new Cache();
        this.compilerPath = "";
        this.builtinPlugins = [];
        this.root = this;
        this.ruleSet = new RuleSetCompiler_1.RuleSetCompiler();
        this.running = false;
        this.idle = false;
        this.context = context;
        this.resolverFactory = new ResolverFactory();
        this.modifiedFiles = undefined;
        this.removedFiles = undefined;
        this.hooks = {
            initialize: new tapable_1.SyncHook([]),
            shouldEmit: new liteTapable.SyncBailHook(["compilation"]),
            done: new tapable.AsyncSeriesHook(["stats"]),
            afterDone: new tapable.SyncHook(["stats"]),
            beforeRun: new tapable.AsyncSeriesHook(["compiler"]),
            run: new tapable.AsyncSeriesHook(["compiler"]),
            emit: new liteTapable.AsyncSeriesHook(["compilation"]),
            assetEmitted: new liteTapable.AsyncSeriesHook(["file", "info"]),
            afterEmit: new liteTapable.AsyncSeriesHook(["compilation"]),
            thisCompilation: new liteTapable.SyncHook(["compilation", "params"]),
            compilation: new liteTapable.SyncHook([
                "compilation",
                "params"
            ]),
            invalid: new tapable_1.SyncHook(["filename", "changeTime"]),
            compile: new tapable_1.SyncHook(["params"]),
            infrastructureLog: new tapable_1.SyncBailHook(["origin", "type", "args"]),
            failed: new tapable_1.SyncHook(["error"]),
            shutdown: new tapable.AsyncSeriesHook([]),
            normalModuleFactory: new tapable.SyncHook([
                "normalModuleFactory"
            ]),
            contextModuleFactory: new tapable.SyncHook([
                "contextModuleFactory"
            ]),
            watchRun: new tapable.AsyncSeriesHook(["compiler"]),
            watchClose: new tapable.SyncHook([]),
            environment: new tapable.SyncHook([]),
            afterEnvironment: new tapable.SyncHook([]),
            afterPlugins: new tapable.SyncHook(["compiler"]),
            afterResolvers: new tapable.SyncHook(["compiler"]),
            make: new liteTapable.AsyncParallelHook(["compilation"]),
            beforeCompile: new tapable.AsyncSeriesHook(["params"]),
            afterCompile: new tapable.AsyncSeriesHook(["compilation"]),
            finishMake: new liteTapable.AsyncSeriesHook(["compilation"]),
            entryOption: new tapable.SyncBailHook(["context", "entry"])
        };
        this.modifiedFiles = undefined;
        this.removedFiles = undefined;
        __classPrivateFieldSet(this, _Compiler_disabledHooks, [], "f");
        __classPrivateFieldSet(this, _Compiler_nonSkippableRegisters, [], "f");
        __classPrivateFieldSet(this, _Compiler_moduleExecutionResultsMap, new Map(), "f");
        new builtin_plugin_1.JsLoaderRspackPlugin(this).apply(this);
        new ExecuteModulePlugin_1.default().apply(this);
    }
    /**
     * @param name - cache name
     * @returns the cache facade instance
     */
    getCache(name) {
        return new CacheFacade(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);
    }
    createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
        const options = {
            ...this.options,
            output: {
                ...this.options.output,
                ...outputOptions
            },
            // TODO: check why we need to have builtins otherwise this.#instance will fail to initialize Rspack
            builtins: this.options.builtins
        };
        (0, defaults_1.applyRspackOptionsDefaults)(options);
        const childCompiler = new Compiler(this.context, options);
        childCompiler.name = compilerName;
        childCompiler.outputPath = this.outputPath;
        childCompiler.inputFileSystem = this.inputFileSystem;
        // childCompiler.outputFileSystem = null;
        childCompiler.resolverFactory = this.resolverFactory;
        childCompiler.modifiedFiles = this.modifiedFiles;
        childCompiler.removedFiles = this.removedFiles;
        // childCompiler.fileTimestamps = this.fileTimestamps;
        // childCompiler.contextTimestamps = this.contextTimestamps;
        // childCompiler.fsStartTime = this.fsStartTime;
        childCompiler.cache = this.cache;
        childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;
        // childCompiler._backCompat = this._backCompat;
        // const relativeCompilerName = makePathsRelative(
        // 	this.context,
        // 	compilerName,
        // 	this.root
        // );
        // if (!this.records[relativeCompilerName]) {
        // 	this.records[relativeCompilerName] = [];
        // }
        // if (this.records[relativeCompilerName][compilerIndex]) {
        // 	childCompiler.records = this.records[relativeCompilerName][compilerIndex];
        // } else {
        // 	this.records[relativeCompilerName].push((childCompiler.records = {}));
        // }
        childCompiler.parentCompilation = compilation;
        childCompiler.root = this.root;
        if (Array.isArray(plugins)) {
            for (const plugin of plugins) {
                if (plugin) {
                    plugin.apply(childCompiler);
                }
            }
        }
        childCompiler.builtinPlugins = [
            ...childCompiler.builtinPlugins,
            ...this.builtinPlugins.filter(plugin => plugin.canInherentFromParent === true)
        ];
        for (const name in this.hooks) {
            if ((0, base_1.canInherentFromParent)(name)) {
                //@ts-ignore
                if (childCompiler.hooks[name]) {
                    //@ts-ignore
                    childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
                }
            }
        }
        compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);
        return childCompiler;
    }
    runAsChild(callback) {
        const finalCallback = (err, entries, compilation) => {
            try {
                callback(err, entries, compilation);
            }
            catch (e) {
                const err = new Error(`compiler.runAsChild callback error: ${e}`);
                // err.details = e.stack;
                this.parentCompilation.errors.push(err);
                // TODO: remove once this works
                console.log(e);
            }
        };
        this.compile((err, compilation) => {
            if (err) {
                return finalCallback(err);
            }
            (0, assertNotNil_1.assertNotNill)(compilation);
            this.parentCompilation.children.push(compilation);
            for (const { name, source, info } of compilation.getAssets()) {
                // Do not emit asset if source is not available.
                // Webpack will emit it anyway.
                if (source) {
                    this.parentCompilation.emitAsset(name, source, info);
                }
            }
            const entries = [];
            for (const ep of compilation.entrypoints.values()) {
                entries.push(...ep.getFiles());
            }
            return finalCallback(null, entries, compilation);
        });
    }
    isChild() {
        const isRoot = this.root === this;
        return !isRoot;
    }
    getInfrastructureLogger(name) {
        if (!name) {
            throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
        }
        return new Logger_1.Logger((type, args) => {
            if (typeof name === "function") {
                name = name();
                if (!name) {
                    throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                }
            }
            else {
                if (
                // @ts-expect-error
                this.hooks.infrastructureLog.call(name, type, args) === undefined) {
                    if (this.infrastructureLogger !== undefined) {
                        this.infrastructureLogger(name, type, args);
                    }
                }
            }
        }, (childName) => {
            if (typeof name === "function") {
                if (typeof childName === "function") {
                    // @ts-expect-error
                    return this.getInfrastructureLogger(_ => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                            }
                        }
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getInfrastructureLogger(() => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
            }
            else {
                if (typeof childName === "function") {
                    return this.getInfrastructureLogger(() => {
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getInfrastructureLogger(`${name}/${childName}`);
                }
            }
        });
    }
    run(callback) {
        if (this.running) {
            return callback(new ConcurrentCompilationError_1.default());
        }
        const startTime = Date.now();
        this.running = true;
        const doRun = () => {
            // @ts-expect-error
            const finalCallback = (err, stats) => {
                this.idle = true;
                this.cache.beginIdle();
                this.idle = true;
                this.running = false;
                if (err) {
                    this.hooks.failed.call(err);
                }
                if (callback) {
                    callback(err, stats);
                }
                this.hooks.afterDone.call(stats);
            };
            this.hooks.beforeRun.callAsync(this, err => {
                if (err) {
                    return finalCallback(err);
                }
                this.hooks.run.callAsync(this, err => {
                    if (err) {
                        return finalCallback(err);
                    }
                    this.compile(err => {
                        if (err) {
                            return finalCallback(err);
                        }
                        this.compilation.startTime = startTime;
                        this.compilation.endTime = Date.now();
                        const stats = new Stats_1.Stats(this.compilation);
                        this.hooks.done.callAsync(stats, err => {
                            if (err) {
                                return finalCallback(err);
                            }
                            else {
                                return finalCallback(null, stats);
                            }
                        });
                    });
                });
            });
        };
        if (this.idle) {
            this.cache.endIdle(err => {
                if (err)
                    return callback(err);
                this.idle = false;
                doRun();
            });
        }
        else {
            doRun();
        }
    }
    /**
     * * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    __internal__rebuild(modifiedFiles, removedFiles, callback) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            if (error) {
                return callback === null || callback === void 0 ? void 0 : callback(error);
            }
            instance.rebuild(Array.from(modifiedFiles || []), Array.from(removedFiles || []), error => {
                if (error) {
                    return callback === null || callback === void 0 ? void 0 : callback(error);
                }
                callback === null || callback === void 0 ? void 0 : callback(null);
            });
        });
    }
    compile(callback) {
        const startTime = Date.now();
        const params = __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_newCompilationParams).call(this);
        this.hooks.beforeCompile.callAsync(params, (err) => {
            if (err) {
                return callback(err);
            }
            this.hooks.compile.call(params);
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_resetThisCompilation).call(this);
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_build).call(this, err => {
                if (err) {
                    return callback(err);
                }
                this.compilation.startTime = startTime;
                this.compilation.endTime = Date.now();
                this.hooks.afterCompile.callAsync(this.compilation, err => {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, this.compilation);
                });
            });
        });
    }
    watch(watchOptions, handler) {
        if (this.running) {
            // @ts-expect-error
            return handler(new ConcurrentCompilationError_1.default());
        }
        this.running = true;
        this.watchMode = true;
        // @ts-expect-error
        this.watching = new Watching_1.Watching(this, watchOptions, handler);
        return this.watching;
    }
    purgeInputFileSystem() {
        if (this.inputFileSystem && this.inputFileSystem.purge) {
            this.inputFileSystem.purge();
        }
    }
    close(callback) {
        if (this.watching) {
            // When there is still an active watching, close this #initial
            this.watching.close(() => {
                this.close(callback);
            });
            return;
        }
        this.hooks.shutdown.callAsync(err => {
            if (err)
                return callback(err);
            this.cache.shutdown(callback);
        });
    }
    getAsset(name) {
        let source = this.compilation.__internal__getAssetSource(name);
        if (!source) {
            return null;
        }
        return source.buffer();
    }
    __internal__registerBuiltinPlugin(plugin) {
        this.builtinPlugins.push(plugin);
    }
    __internal__getModuleExecutionResult(id) {
        return __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").get(id);
    }
}
exports.Compiler = Compiler;
_Compiler_instance = new WeakMap(), _Compiler_initial = new WeakMap(), _Compiler_disabledHooks = new WeakMap(), _Compiler_nonSkippableRegisters = new WeakMap(), _Compiler_registers = new WeakMap(), _Compiler_moduleExecutionResultsMap = new WeakMap(), _Compiler_instances = new WeakSet(), _Compiler_getInstance = function _Compiler_getInstance(callback) {
    const error = (0, bindingVersionCheck_1.checkVersion)();
    if (error) {
        return callback(error);
    }
    if (__classPrivateFieldGet(this, _Compiler_instance, "f")) {
        return callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
    }
    const options = this.options;
    // TODO: remove this when drop support for builtins options
    options.builtins = (0, builtin_plugin_1.deprecated_resolveBuiltins)(options.builtins, options);
    const rawOptions = (0, config_1.getRawOptions)(options, this);
    const instanceBinding = require("@rspack/binding");
    __classPrivateFieldSet(this, _Compiler_registers, {
        registerCompilerThisCompilationTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerThisCompilation, () => this.hooks.thisCompilation, queried => (native) => {
            if (this.compilation === undefined) {
                __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createCompilation).call(this, native);
            }
            queried.call(this.compilation, this.compilationParams);
        }),
        registerCompilerCompilationTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerCompilation, () => this.hooks.compilation, queried => () => queried.call(this.compilation, this.compilationParams)),
        registerCompilerMakeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerMake, () => this.hooks.make, queried => async () => await queried.promise(this.compilation)),
        registerCompilerFinishMakeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerFinishMake, () => this.hooks.finishMake, queried => async () => await queried.promise(this.compilation)),
        registerCompilerShouldEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerShouldEmit, () => this.hooks.shouldEmit, queried => () => queried.call(this.compilation)),
        registerCompilerEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerEmit, () => this.hooks.emit, queried => async () => await queried.promise(this.compilation)),
        registerCompilerAfterEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerAfterEmit, () => this.hooks.afterEmit, queried => async () => await queried.promise(this.compilation)),
        registerCompilerAssetEmittedTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerAssetEmitted, () => this.hooks.assetEmitted, queried => async ({ filename, targetPath, outputPath }) => {
            return queried.promise(filename, {
                compilation: this.compilation,
                targetPath,
                outputPath,
                get source() {
                    var _a;
                    return (_a = this.compilation.getAsset(filename)) === null || _a === void 0 ? void 0 : _a.source;
                },
                get content() {
                    var _a;
                    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.buffer();
                }
            });
        }),
        registerCompilationRuntimeModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationRuntimeModule, () => this.compilation.hooks.runtimeModule, queried => ({ module, chunk }) => {
            var _a, _b;
            const originSource = (_a = module.source) === null || _a === void 0 ? void 0 : _a.source;
            queried.call(module, Chunk_1.Chunk.__from_binding(chunk, this.compilation));
            const newSource = (_b = module.source) === null || _b === void 0 ? void 0 : _b.source;
            if (newSource && newSource !== originSource) {
                return module;
            }
            return;
        }),
        registerCompilationBuildModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationBuildModule, () => this.compilation.hooks.buildModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m))),
        registerCompilationStillValidModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationStillValidModule, () => this.compilation.hooks.stillValidModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m))),
        registerCompilationSucceedModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationSucceedModule, () => this.compilation.hooks.succeedModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m))),
        registerCompilationExecuteModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationExecuteModule, () => this.compilation.hooks.executeModule, queried => ({ entry, id, codegenResults, runtimeModules }) => {
            const __webpack_require__ = (id) => {
                const cached = moduleCache[id];
                if (cached !== undefined) {
                    if (cached.error)
                        throw cached.error;
                    return cached.exports;
                }
                var execOptions = {
                    id,
                    module: {
                        id,
                        exports: {},
                        loaded: false,
                        error: undefined
                    },
                    require: __webpack_require__
                };
                interceptModuleExecution.forEach((handler) => handler(execOptions));
                const result = codegenResults.map[id]["build time"];
                const moduleObject = execOptions.module;
                if (id)
                    moduleCache[id] = moduleObject;
                (0, HookWebpackError_1.tryRunOrWebpackError)(() => queried.call({
                    codeGenerationResult: new Module_1.CodeGenerationResult(result),
                    moduleObject
                }, { __webpack_require__ }), "Compilation.hooks.executeModule");
                moduleObject.loaded = true;
                return moduleObject.exports;
            };
            const moduleCache = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.moduleCache.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = {});
            const interceptModuleExecution = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.interceptModuleExecution.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = []);
            for (const runtimeModule of runtimeModules) {
                __webpack_require__(runtimeModule);
            }
            const executeResult = __webpack_require__(entry);
            __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").set(id, executeResult);
        }),
        registerCompilationFinishModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationFinishModules, () => this.compilation.hooks.finishModules, queried => async () => await queried.promise(this.compilation.modules)),
        registerCompilationOptimizeModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeModules, () => this.compilation.hooks.optimizeModules, queried => () => queried.call(this.compilation.modules)),
        registerCompilationAfterOptimizeModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterOptimizeModules, () => this.compilation.hooks.afterOptimizeModules, queried => () => queried.call(this.compilation.modules)),
        registerCompilationOptimizeTreeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeTree, () => this.compilation.hooks.optimizeTree, queried => async () => await queried.promise(this.compilation.chunks, this.compilation.modules)),
        registerCompilationOptimizeChunkModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeChunkModules, () => this.compilation.hooks.optimizeChunkModules, queried => async () => await queried.promise(this.compilation.chunks, this.compilation.modules)),
        registerCompilationChunkAssetTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationChunkAsset, () => this.compilation.hooks.chunkAsset, queried => ({ chunk, filename }) => queried.call(Chunk_1.Chunk.__from_binding(chunk, this.compilation), filename)),
        registerCompilationProcessAssetsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationProcessAssets, () => this.compilation.hooks.processAssets, queried => async () => await queried.promise(this.compilation.assets)),
        registerCompilationAfterProcessAssetsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterProcessAssets, () => this.compilation.hooks.afterProcessAssets, queried => () => queried.call(this.compilation.assets)),
        registerCompilationAfterSealTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterSeal, () => this.compilation.hooks.afterSeal, queried => async () => await queried.promise()),
        registerNormalModuleFactoryBeforeResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryBeforeResolve, () => this.compilationParams.normalModuleFactory.hooks.beforeResolve, queried => async (resolveData) => {
            const normalizedResolveData = {
                request: resolveData.request,
                context: resolveData.context,
                fileDependencies: [],
                missingDependencies: [],
                contextDependencies: []
            };
            const ret = await queried.promise(normalizedResolveData);
            resolveData.request = normalizedResolveData.request;
            resolveData.context = normalizedResolveData.context;
            return [ret, resolveData];
        }),
        registerNormalModuleFactoryResolveForSchemeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookMapRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryResolveForScheme, () => this.compilationParams.normalModuleFactory.hooks.resolveForScheme, queried => async (args) => {
            const ret = await queried
                .for(args.scheme)
                .promise(args.resourceData);
            return [ret, args.resourceData];
        }),
        registerNormalModuleFactoryAfterResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryAfterResolve, () => this.compilationParams.normalModuleFactory.hooks.afterResolve, queried => async (arg) => {
            const data = {
                request: arg.request,
                context: arg.context,
                fileDependencies: arg.fileDependencies,
                missingDependencies: arg.missingDependencies,
                contextDependencies: arg.contextDependencies,
                createData: arg.createData
            };
            const ret = await queried.promise(data);
            return [ret, data.createData];
        }),
        registerNormalModuleFactoryCreateModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryCreateModule, () => this.compilationParams.normalModuleFactory.hooks.createModule, queried => async (args) => {
            const data = {
                ...args,
                settings: {}
            };
            await queried.promise(data, {});
        }),
        registerContextModuleFactoryBeforeResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.ContextModuleFactoryBeforeResolve, () => this.compilationParams.contextModuleFactory.hooks.beforeResolve, queried => async (arg) => {
            const data = {
                request: arg.request,
                context: arg.context,
                fileDependencies: [],
                missingDependencies: [],
                contextDependencies: []
            };
            const ret = await queried.promise(data);
            return [ret, data];
        }),
        registerContextModuleFactoryAfterResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.ContextModuleFactoryAfterResolve, () => this.compilationParams.contextModuleFactory.hooks.afterResolve, queried => async (arg) => {
            const data = {
                request: arg.request,
                context: arg.context,
                fileDependencies: arg.fileDependencies,
                missingDependencies: arg.missingDependencies,
                contextDependencies: arg.contextDependencies,
                createData: arg.createData
            };
            return await queried.promise(data);
        })
    }, "f");
    __classPrivateFieldSet(this, _Compiler_instance, new instanceBinding.Rspack(rawOptions, this.builtinPlugins, __classPrivateFieldGet(this, _Compiler_registers, "f"), (0, fileSystem_1.createThreadsafeNodeFSFromRaw)(this.outputFileSystem)), "f");
    callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
}, _Compiler_updateNonSkippableRegisters = function _Compiler_updateNonSkippableRegisters() {
    const kinds = [];
    for (const { getHook, getHookMap, registerKind } of Object.values(__classPrivateFieldGet(this, _Compiler_registers, "f"))) {
        const get = getHook !== null && getHook !== void 0 ? getHook : getHookMap;
        const hookOrMap = get();
        if (hookOrMap.isUsed()) {
            kinds.push(registerKind);
        }
    }
    if (__classPrivateFieldGet(this, _Compiler_nonSkippableRegisters, "f").join() !== kinds.join()) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            instance.setNonSkippableRegisters(kinds);
            __classPrivateFieldSet(this, _Compiler_nonSkippableRegisters, kinds, "f");
        });
    }
}, _Compiler_decorateJsTaps = function _Compiler_decorateJsTaps(jsTaps) {
    if (jsTaps.length > 0) {
        const last = jsTaps[jsTaps.length - 1];
        const old = last.function;
        last.function = (...args) => {
            const result = old(...args);
            if (result && typeof result.then === "function") {
                return result.then((r) => {
                    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateNonSkippableRegisters).call(this);
                    return r;
                });
            }
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateNonSkippableRegisters).call(this);
            return result;
        };
    }
}, _Compiler_createHookRegisterTaps = function _Compiler_createHookRegisterTaps(registerKind, getHook, createTap) {
    const getTaps = (stages) => {
        const hook = getHook();
        if (!hook.isUsed())
            return [];
        const breakpoints = [
            liteTapable.minStage,
            ...stages,
            liteTapable.maxStage
        ];
        const jsTaps = [];
        for (let i = 0; i < breakpoints.length - 1; i++) {
            const from = breakpoints[i];
            const to = breakpoints[i + 1];
            const stageRange = [from, to];
            const queried = hook.queryStageRange(stageRange);
            if (!queried.isUsed())
                continue;
            jsTaps.push({
                function: createTap(queried),
                stage: liteTapable.safeStage(from + 1)
            });
        }
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_decorateJsTaps).call(this, jsTaps);
        return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHook = getHook;
    return getTaps;
}, _Compiler_createHookMapRegisterTaps = function _Compiler_createHookMapRegisterTaps(registerKind, getHookMap, createTap) {
    const getTaps = (stages) => {
        const map = getHookMap();
        if (!map.isUsed())
            return [];
        const breakpoints = [
            liteTapable.minStage,
            ...stages,
            liteTapable.maxStage
        ];
        const jsTaps = [];
        for (let i = 0; i < breakpoints.length - 1; i++) {
            const from = breakpoints[i];
            const to = breakpoints[i + 1];
            const stageRange = [from, to];
            const queried = map.queryStageRange(stageRange);
            if (!queried.isUsed())
                continue;
            jsTaps.push({
                function: createTap(queried),
                stage: liteTapable.safeStage(from + 1)
            });
        }
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_decorateJsTaps).call(this, jsTaps);
        return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHookMap = getHookMap;
    return getTaps;
}, _Compiler_build = function _Compiler_build(callback) {
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
        if (error) {
            return callback === null || callback === void 0 ? void 0 : callback(error);
        }
        if (!__classPrivateFieldGet(this, _Compiler_initial, "f")) {
            instance.rebuild(Array.from(this.modifiedFiles || []), Array.from(this.removedFiles || []), error => {
                if (error) {
                    return callback === null || callback === void 0 ? void 0 : callback(error);
                }
                callback === null || callback === void 0 ? void 0 : callback(null);
            });
            return;
        }
        __classPrivateFieldSet(this, _Compiler_initial, false, "f");
        instance.build(error => {
            if (error) {
                return callback === null || callback === void 0 ? void 0 : callback(error);
            }
            callback === null || callback === void 0 ? void 0 : callback(null);
        });
    });
}, _Compiler_createCompilation = function _Compiler_createCompilation(native) {
    const compilation = new Compilation_1.Compilation(this, native);
    compilation.name = this.name;
    this.compilation = compilation;
    return compilation;
}, _Compiler_resetThisCompilation = function _Compiler_resetThisCompilation() {
    // reassign new compilation in thisCompilation
    this.compilation = undefined;
    // ensure thisCompilation must call
    this.hooks.thisCompilation.intercept({
        call: () => { }
    });
}, _Compiler_newCompilationParams = function _Compiler_newCompilationParams() {
    const normalModuleFactory = new NormalModuleFactory_1.NormalModuleFactory();
    this.hooks.normalModuleFactory.call(normalModuleFactory);
    const contextModuleFactory = new ContextModuleFactory_1.ContextModuleFactory();
    this.hooks.contextModuleFactory.call(contextModuleFactory);
    const params = {
        normalModuleFactory,
        contextModuleFactory
    };
    this.compilationParams = params;
    return params;
};
