/// <reference types="node" />
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
import * as binding from "@rspack/binding";
import * as tapable from "tapable";
import * as liteTapable from "./lite-tapable";
import { Callback } from "tapable";
import type Watchpack from "../compiled/watchpack";
import { EntryNormalized, OutputNormalized, RspackOptionsNormalized, RspackPluginInstance } from "./config";
import { RuleSetCompiler } from "./RuleSetCompiler";
import { Stats } from "./Stats";
import { Compilation, CompilationParams } from "./Compilation";
import { ContextModuleFactory } from "./ContextModuleFactory";
import ResolverFactory = require("./ResolverFactory");
import Cache = require("./lib/Cache");
import CacheFacade = require("./lib/CacheFacade");
import { Logger } from "./logging/Logger";
import { NormalModuleFactory } from "./NormalModuleFactory";
import { WatchFileSystem } from "./util/fs";
import { Watching } from "./Watching";
import { FileSystemInfoEntry } from "./FileSystemInfo";
import { Source } from "webpack-sources";
export interface AssetEmittedInfo {
    content: Buffer;
    source: Source;
    outputPath: string;
    targetPath: string;
    compilation: Compilation;
}
declare class Compiler {
    #private;
    webpack: typeof import("./rspack").rspack & typeof import("./exports") & {
        rspack: typeof import("./rspack").rspack & typeof import("./exports") & any;
        webpack: typeof import("./rspack").rspack & typeof import("./exports") & any;
    };
    compilation?: Compilation;
    compilationParams?: CompilationParams;
    builtinPlugins: binding.BuiltinPlugin[];
    root: Compiler;
    running: boolean;
    idle: boolean;
    resolverFactory: ResolverFactory;
    infrastructureLogger: any;
    watching?: Watching;
    outputPath: string;
    name?: string;
    inputFileSystem: any;
    outputFileSystem: typeof import("fs");
    ruleSet: RuleSetCompiler;
    watchFileSystem: WatchFileSystem;
    intermediateFileSystem: any;
    watchMode: boolean;
    context: string;
    cache: Cache;
    compilerPath: string;
    modifiedFiles?: ReadonlySet<string>;
    removedFiles?: ReadonlySet<string>;
    fileTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    contextTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    hooks: {
        done: tapable.AsyncSeriesHook<Stats>;
        afterDone: tapable.SyncHook<Stats>;
        thisCompilation: liteTapable.SyncHook<[Compilation, CompilationParams]>;
        compilation: liteTapable.SyncHook<[Compilation, CompilationParams]>;
        invalid: tapable.SyncHook<[string | null, number]>;
        compile: tapable.SyncHook<[CompilationParams]>;
        normalModuleFactory: tapable.SyncHook<NormalModuleFactory>;
        contextModuleFactory: tapable.SyncHook<ContextModuleFactory>;
        initialize: tapable.SyncHook<[]>;
        shouldEmit: liteTapable.SyncBailHook<[Compilation], boolean>;
        infrastructureLog: tapable.SyncBailHook<[string, string, any[]], true>;
        beforeRun: tapable.AsyncSeriesHook<[Compiler]>;
        run: tapable.AsyncSeriesHook<[Compiler]>;
        emit: liteTapable.AsyncSeriesHook<[Compilation]>;
        assetEmitted: liteTapable.AsyncSeriesHook<[string, AssetEmittedInfo]>;
        afterEmit: liteTapable.AsyncSeriesHook<[Compilation]>;
        failed: tapable.SyncHook<[Error]>;
        shutdown: tapable.AsyncSeriesHook<[]>;
        watchRun: tapable.AsyncSeriesHook<[Compiler]>;
        watchClose: tapable.SyncHook<[]>;
        environment: tapable.SyncHook<[]>;
        afterEnvironment: tapable.SyncHook<[]>;
        afterPlugins: tapable.SyncHook<[Compiler]>;
        afterResolvers: tapable.SyncHook<[Compiler]>;
        make: liteTapable.AsyncParallelHook<[Compilation]>;
        beforeCompile: tapable.AsyncSeriesHook<[CompilationParams]>;
        afterCompile: tapable.AsyncSeriesHook<[Compilation]>;
        finishMake: liteTapable.AsyncSeriesHook<[Compilation]>;
        entryOption: tapable.SyncBailHook<[string, EntryNormalized], any>;
    };
    options: RspackOptionsNormalized;
    parentCompilation?: Compilation;
    constructor(context: string, options: RspackOptionsNormalized);
    /**
     * @param name - cache name
     * @returns the cache facade instance
     */
    getCache(name: string): CacheFacade;
    createChildCompiler(compilation: Compilation, compilerName: string, compilerIndex: number, outputOptions: OutputNormalized, plugins: RspackPluginInstance[]): Compiler;
    runAsChild(callback: any): void;
    isChild(): boolean;
    getInfrastructureLogger(name: string | Function): Logger;
    run(callback: Callback<Error, Stats>): void;
    /**
     * * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    __internal__rebuild(modifiedFiles?: ReadonlySet<string>, removedFiles?: ReadonlySet<string>, callback?: (error: Error | null) => void): void;
    compile(callback: Callback<Error, Compilation>): void;
    watch(watchOptions: Watchpack.WatchOptions, handler: Callback<Error, Stats>): Watching;
    purgeInputFileSystem(): void;
    close(callback: (error?: Error | null) => void): void;
    getAsset(name: string): Buffer | null;
    __internal__registerBuiltinPlugin(plugin: binding.BuiltinPlugin): void;
    __internal__getModuleExecutionResult(id: number): any;
}
export { Compiler };
