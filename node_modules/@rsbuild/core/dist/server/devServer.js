"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var devServer_exports = {};
__export(devServer_exports, {
  createDevServer: () => createDevServer
});
module.exports = __toCommonJS(devServer_exports);
var import_node_fs = __toESM(require("node:fs"));
var import_shared = require("@rsbuild/shared");
var import_connect = __toESM(require("@rsbuild/shared/connect"));
var import_getDevMiddlewares = require("./getDevMiddlewares");
var import_helper = require("./helper");
var import_httpServer = require("./httpServer");
var import_middlewares = require("./middlewares");
var import_restart = require("./restart");
var import_watchFiles = require("./watchFiles");
async function createDevServer(options, createDevMiddleware, {
  compiler: customCompiler,
  getPortSilently,
  runCompile = true
} = {}) {
  if (!(0, import_shared.getNodeEnv)()) {
    (0, import_shared.setNodeEnv)("development");
  }
  (0, import_shared.debug)("create dev server");
  const rsbuildConfig = options.context.config;
  const { devConfig, serverConfig, port, host, https } = await (0, import_helper.getDevOptions)({
    rsbuildConfig,
    getPortSilently
  });
  const routes = (0, import_helper.formatRoutes)(
    options.context.entry,
    rsbuildConfig.output?.distPath?.html,
    rsbuildConfig.html?.outputStructure
  );
  options.context.devServer = {
    hostname: host,
    port,
    https
  };
  let outputFileSystem = import_node_fs.default;
  const startCompile = async () => {
    const { devMiddleware, compiler } = await createDevMiddleware(
      options,
      customCompiler
    );
    const { CompilerDevMiddleware } = await Promise.resolve().then(() => __toESM(require("./compilerDevMiddleware")));
    const publicPaths = (0, import_shared.isMultiCompiler)(compiler) ? compiler.compilers.map(import_shared.getPublicPathFromCompiler) : [(0, import_shared.getPublicPathFromCompiler)(compiler)];
    const compilerDevMiddleware = new CompilerDevMiddleware({
      dev: devConfig,
      server: serverConfig,
      publicPaths,
      devMiddleware
    });
    compilerDevMiddleware.init();
    outputFileSystem = (0, import_shared.isMultiCompiler)(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem;
    return {
      middleware: compilerDevMiddleware.middleware,
      sockWrite: (...args) => compilerDevMiddleware.sockWrite(...args),
      onUpgrade: (...args) => compilerDevMiddleware.upgrade(...args),
      close: () => compilerDevMiddleware?.close()
    };
  };
  const protocol = https ? "https" : "http";
  const urls = (0, import_shared.getAddressUrls)({ protocol, port, host });
  await options.context.hooks.onBeforeStartDevServer.call();
  if (runCompile) {
    options.context.hooks.onBeforeCreateCompiler.tap(() => {
      (0, import_helper.printServerURLs)({
        urls,
        port,
        routes,
        protocol,
        printUrls: serverConfig.printUrls
      });
    });
  } else {
    (0, import_helper.printServerURLs)({
      urls,
      port,
      routes,
      protocol,
      printUrls: serverConfig.printUrls
    });
  }
  const compileMiddlewareAPI = runCompile ? await startCompile() : void 0;
  const fileWatcher = await (0, import_watchFiles.setupWatchFiles)({
    dev: devConfig,
    server: serverConfig,
    compileMiddlewareAPI
  });
  const devMiddlewares = await (0, import_getDevMiddlewares.getMiddlewares)({
    pwd: options.context.rootPath,
    compileMiddlewareAPI,
    dev: devConfig,
    server: serverConfig,
    output: {
      distPath: rsbuildConfig.output?.distPath?.root || import_shared.ROOT_DIST_DIR
    },
    outputFileSystem
  });
  const middlewares = (0, import_connect.default)();
  for (const item of devMiddlewares.middlewares) {
    if (Array.isArray(item)) {
      middlewares.use(...item);
    } else {
      middlewares.use(item);
    }
  }
  const server = {
    port,
    middlewares,
    outputFileSystem,
    listen: async () => {
      const httpServer = await (0, import_httpServer.createHttpServer)({
        https: serverConfig.https,
        middlewares
      });
      (0, import_shared.debug)("listen dev server");
      return new Promise((resolve) => {
        httpServer.listen(
          {
            host,
            port
          },
          async (err) => {
            if (err) {
              throw err;
            }
            middlewares.use(import_middlewares.notFoundMiddleware);
            httpServer.on("upgrade", devMiddlewares.onUpgrade);
            (0, import_shared.debug)("listen dev server done");
            await server.afterListen();
            const closeServer = async () => {
              await server.close();
              httpServer.close();
            };
            (0, import_restart.onBeforeRestartServer)(closeServer);
            resolve({
              port,
              urls: urls.map((item) => item.url),
              server: {
                close: closeServer
              }
            });
          }
        );
      });
    },
    afterListen: async () => {
      await options.context.hooks.onAfterStartDevServer.call({
        port,
        routes
      });
    },
    onHTTPUpgrade: devMiddlewares.onUpgrade,
    close: async () => {
      await options.context.hooks.onCloseDevServer.call();
      await devMiddlewares.close();
      await fileWatcher?.close();
    }
  };
  (0, import_shared.debug)("create dev server done");
  return server;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDevServer
});
