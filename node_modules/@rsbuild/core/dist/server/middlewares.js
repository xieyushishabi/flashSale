"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var middlewares_exports = {};
__export(middlewares_exports, {
  faviconFallbackMiddleware: () => faviconFallbackMiddleware,
  getHtmlFallbackMiddleware: () => getHtmlFallbackMiddleware,
  getRequestLoggerMiddleware: () => getRequestLoggerMiddleware,
  notFoundMiddleware: () => notFoundMiddleware
});
module.exports = __toCommonJS(middlewares_exports);
var import_node_path = __toESM(require("node:path"));
var import_node_url = require("node:url");
var import_shared = require("@rsbuild/shared");
const faviconFallbackMiddleware = (req, res, next) => {
  if (req.url === "/favicon.ico") {
    res.statusCode = 204;
    res.end();
  } else {
    next();
  }
};
const getStatusCodeColor = (status) => {
  if (status >= 500) {
    return import_shared.color.red;
  }
  if (status >= 400) {
    return import_shared.color.yellow;
  }
  if (status >= 300) {
    return import_shared.color.cyan;
  }
  if (status >= 200) {
    return import_shared.color.green;
  }
  return (res) => res;
};
const getRequestLoggerMiddleware = async () => {
  const { default: onFinished } = await Promise.resolve().then(() => __toESM(require("../../compiled/on-finished")));
  return (req, res, next) => {
    const _startAt = process.hrtime();
    const logRequest = () => {
      const method = req.method;
      const url = req.originalUrl || req.url;
      const status = Number(res.statusCode);
      const statusColor = getStatusCodeColor(status);
      const endAt = process.hrtime();
      const totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
      (0, import_shared.debug)(
        `${statusColor(status)} ${method} ${import_shared.color.gray(url)} ${import_shared.color.gray(
          `${totalTime.toFixed(3)} ms`
        )}`
      );
    };
    onFinished(res, logRequest);
    next();
  };
};
const notFoundMiddleware = (_req, res, _next) => {
  res.statusCode = 404;
  res.end();
};
const getHtmlFallbackMiddleware = ({ htmlFallback, distPath, callback, outputFileSystem }) => {
  return (req, res, next) => {
    if (
      // Only accept GET or HEAD
      req.method !== "GET" && req.method !== "HEAD" || // Require Accept header
      !req.headers || typeof req.headers.accept !== "string" || // Ignore JSON requests
      req.headers.accept.includes("application/json") || // Require Accept: text/html or */*
      !(req.headers.accept.includes("text/html") || req.headers.accept.includes("*/*")) || !req.url || ["/favicon.ico"].includes(req.url)
    ) {
      return next();
    }
    const { url } = req;
    let pathname = url;
    try {
      pathname = (0, import_node_url.parse)(url, false, true).pathname;
    } catch (err) {
      import_shared.logger.error(
        new Error(`Invalid URL: ${import_shared.color.yellow(url)}`, { cause: err })
      );
      return next();
    }
    const rewrite = (newUrl, isFallback = false) => {
      if (isFallback && (0, import_shared.isDebug)()) {
        (0, import_shared.debug)(
          `${req.method} ${import_shared.color.gray(
            `${req.url} ${import_shared.color.yellow("fallback")} to ${newUrl}`
          )}`
        );
      }
      req.url = newUrl;
      if (callback) {
        return callback(req, res, (...args) => {
          next(...args);
        });
      }
      return next();
    };
    if (pathname.endsWith("/")) {
      const newUrl = `${pathname}index.html`;
      const filePath = import_node_path.default.join(distPath, pathname, "index.html");
      if (outputFileSystem.existsSync(filePath)) {
        return rewrite(newUrl);
      }
    } else if (
      // '/main' => '/main.html'
      !pathname.endsWith(".html")
    ) {
      const newUrl = `${pathname}.html`;
      const filePath = import_node_path.default.join(distPath, `${pathname}.html`);
      if (outputFileSystem.existsSync(filePath)) {
        return rewrite(newUrl);
      }
    }
    if (htmlFallback === "index") {
      if (outputFileSystem.existsSync(import_node_path.default.join(distPath, "index.html"))) {
        return rewrite("/index.html", true);
      }
    }
    next();
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  faviconFallbackMiddleware,
  getHtmlFallbackMiddleware,
  getRequestLoggerMiddleware,
  notFoundMiddleware
});
