"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var fileSize_exports = {};
__export(fileSize_exports, {
  filterAsset: () => filterAsset,
  pluginFileSize: () => pluginFileSize
});
module.exports = __toCommonJS(fileSize_exports);
var import_node_path = __toESM(require("node:path"));
var import_shared = require("@rsbuild/shared");
var import_shared2 = require("@rsbuild/shared");
const filterAsset = (asset) => !/\.map$/.test(asset) && !/\.LICENSE\.txt$/.test(asset);
const getAssetColor = (size) => {
  if (size > 300 * 1e3) {
    return import_shared2.color.red;
  }
  if (size > 100 * 1e3) {
    return import_shared2.color.yellow;
  }
  return import_shared2.color.green;
};
async function printHeader(longestFileLength, longestLabelLength) {
  const longestLengths = [longestFileLength, longestLabelLength];
  const headerRow = ["File", "Size", "Gzipped"].reduce((prev, cur, index) => {
    const length = longestLengths[index];
    let curLabel = cur;
    if (length) {
      curLabel = cur.length < length ? cur + " ".repeat(length - cur.length) : cur;
    }
    return `${prev + curLabel}    `;
  }, "  ");
  import_shared2.logger.log(import_shared2.color.bold(import_shared2.color.blue(headerRow)));
}
const calcFileSize = (len) => {
  const val = len / 1e3;
  return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
};
const coloringAssetName = (assetName) => {
  if (import_shared.JS_REGEX.test(assetName)) {
    return import_shared2.color.cyan(assetName);
  }
  if (import_shared.CSS_REGEX.test(assetName)) {
    return import_shared2.color.yellow(assetName);
  }
  if (import_shared.HTML_REGEX.test(assetName)) {
    return import_shared2.color.green(assetName);
  }
  return import_shared2.color.magenta(assetName);
};
async function printFileSizes(config, stats, rootPath) {
  if (config.detail === false && config.total === false) {
    return;
  }
  const { default: gzipSize } = await Promise.resolve().then(() => __toESM(require("@rsbuild/shared/gzip-size")));
  const formatAsset = (asset, distPath, distFolder) => {
    const fileName = asset.name.split("?")[0];
    const contents = import_shared.fse.readFileSync(import_node_path.default.join(distPath, fileName));
    const size = contents.length;
    const gzippedSize = gzipSize.sync(contents);
    return {
      size,
      folder: import_node_path.default.join(distFolder, import_node_path.default.dirname(fileName)),
      name: import_node_path.default.basename(fileName),
      gzippedSize,
      sizeLabel: calcFileSize(size),
      gzipSizeLabel: getAssetColor(gzippedSize)(calcFileSize(gzippedSize))
    };
  };
  const multiStats = "stats" in stats ? stats.stats : [stats];
  const assets = multiStats.map((stats2) => {
    const distPath = stats2.compilation.outputOptions.path;
    if (!distPath) {
      return [];
    }
    const origin = stats2.toJson({
      all: false,
      assets: true,
      // TODO: need supported in rspack
      // @ts-expect-error
      cachedAssets: true,
      groupAssetsByInfo: false,
      groupAssetsByPath: false,
      groupAssetsByChunk: false,
      groupAssetsByExtension: false,
      groupAssetsByEmitStatus: false
    });
    const filteredAssets = origin.assets.filter(
      (asset) => filterAsset(asset.name)
    );
    const distFolder = import_node_path.default.relative(rootPath, distPath);
    return filteredAssets.map(
      (asset) => formatAsset(asset, distPath, distFolder)
    );
  }).reduce((single, all) => all.concat(single), []);
  if (assets.length === 0) {
    return;
  }
  assets.sort((a, b) => a.size - b.size);
  import_shared2.logger.info("Production file sizes:\n");
  const longestLabelLength = Math.max(...assets.map((a) => a.sizeLabel.length));
  const longestFileLength = Math.max(
    ...assets.map((a) => (a.folder + import_node_path.default.sep + a.name).length)
  );
  if (config.detail !== false) {
    printHeader(longestFileLength, longestLabelLength);
  }
  let totalSize = 0;
  let totalGzipSize = 0;
  for (const asset of assets) {
    let { sizeLabel } = asset;
    const { name, folder, gzipSizeLabel } = asset;
    const fileNameLength = (folder + import_node_path.default.sep + name).length;
    const sizeLength = sizeLabel.length;
    totalSize += asset.size;
    totalGzipSize += asset.gzippedSize;
    if (config.detail !== false) {
      if (sizeLength < longestLabelLength) {
        const rightPadding = " ".repeat(longestLabelLength - sizeLength);
        sizeLabel += rightPadding;
      }
      let fileNameLabel = import_shared2.color.dim(asset.folder + import_node_path.default.sep) + coloringAssetName(asset.name);
      if (fileNameLength < longestFileLength) {
        const rightPadding = " ".repeat(longestFileLength - fileNameLength);
        fileNameLabel += rightPadding;
      }
      import_shared2.logger.log(`  ${fileNameLabel}    ${sizeLabel}    ${gzipSizeLabel}`);
    }
  }
  if (config.total !== false) {
    const totalSizeLabel = `${import_shared2.color.bold(
      import_shared2.color.blue("Total size:")
    )}  ${calcFileSize(totalSize)}`;
    const gzippedSizeLabel = `${import_shared2.color.bold(
      import_shared2.color.blue("Gzipped size:")
    )}  ${calcFileSize(totalGzipSize)}`;
    import_shared2.logger.log(`
  ${totalSizeLabel}
  ${gzippedSizeLabel}
`);
  }
}
const pluginFileSize = () => ({
  name: "rsbuild:file-size",
  setup(api) {
    api.onAfterBuild(async ({ stats }) => {
      const { printFileSize } = api.getNormalizedConfig().performance;
      if (printFileSize === false) {
        return;
      }
      const printFileSizeConfig = typeof printFileSize === "boolean" ? {
        total: true,
        detail: true
      } : printFileSize;
      if (stats) {
        try {
          await printFileSizes(
            printFileSizeConfig,
            stats,
            api.context.rootPath
          );
        } catch (err) {
          import_shared2.logger.warn("Failed to print file size.");
          import_shared2.logger.warn(err);
        }
      }
    });
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  filterAsset,
  pluginFileSize
});
