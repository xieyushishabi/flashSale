"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var html_exports = {};
__export(html_exports, {
  getFavicon: () => getFavicon,
  getInject: () => getInject,
  getMetaTags: () => getMetaTags,
  getTemplate: () => getTemplate,
  getTitle: () => getTitle,
  pluginHtml: () => pluginHtml
});
module.exports = __toCommonJS(html_exports);
var import_node_path = __toESM(require("node:path"));
var import_shared = require("@rsbuild/shared");
function getTitle(entryName, config) {
  return (0, import_shared.mergeChainedOptions)({
    defaults: "",
    options: config.html.title,
    utils: { entryName },
    useObjectParam: true
  });
}
function getInject(entryName, config) {
  return (0, import_shared.mergeChainedOptions)({
    defaults: "head",
    options: config.html.inject,
    utils: { entryName },
    useObjectParam: true,
    isFalsy: import_shared.isNil
  });
}
const existTemplatePath = [];
async function getTemplate(entryName, config, rootPath) {
  const DEFAULT_TEMPLATE = import_node_path.default.resolve(
    __dirname,
    "../../static/template.html"
  );
  const templatePath = (0, import_shared.mergeChainedOptions)({
    defaults: DEFAULT_TEMPLATE,
    options: config.html.template,
    utils: { entryName },
    useObjectParam: true
  });
  if (templatePath === DEFAULT_TEMPLATE) {
    return {
      templatePath
    };
  }
  const absolutePath = (0, import_node_path.isAbsolute)(templatePath) ? templatePath : import_node_path.default.resolve(rootPath, templatePath);
  if (!existTemplatePath.includes(absolutePath)) {
    if (!await (0, import_shared.isFileExists)(absolutePath)) {
      throw new Error(
        `Failed to resolve HTML template, please check if the file exists: ${import_shared.color.cyan(
          absolutePath
        )}`
      );
    }
    existTemplatePath.push(absolutePath);
  }
  const templateContent = await import_shared.fse.readFile(absolutePath, "utf-8");
  return {
    templatePath: absolutePath,
    templateContent
  };
}
function getFavicon(entryName, config) {
  return (0, import_shared.mergeChainedOptions)({
    defaults: "",
    options: config.html.favicon,
    utils: { entryName },
    useObjectParam: true
  });
}
function getMetaTags(entryName, config, templateContent) {
  const metaTags = (0, import_shared.mergeChainedOptions)({
    defaults: {},
    options: config.html.meta,
    utils: { entryName },
    useObjectParam: true
  });
  if (templateContent && metaTags.charset) {
    const charsetRegExp = /<meta[^>]+charset=["'][^>]*>/i;
    if (charsetRegExp.test(templateContent)) {
      delete metaTags.charset;
    }
  }
  return metaTags;
}
function getTemplateParameters(entryName, config, assetPrefix) {
  return (compilation, assets, assetTags, pluginOptions) => {
    const { mountId, templateParameters } = config.html;
    const defaultOptions = {
      mountId,
      entryName,
      assetPrefix,
      compilation,
      webpackConfig: compilation.options,
      htmlWebpackPlugin: {
        tags: assetTags,
        files: assets,
        options: pluginOptions
      }
    };
    return (0, import_shared.mergeChainedOptions)({
      defaults: defaultOptions,
      options: templateParameters,
      utils: { entryName }
    });
  };
}
function getChunks(entryName, entryValue) {
  const chunks = [entryName];
  for (const item of entryValue) {
    if (!(0, import_shared.isPlainObject)(item)) {
      continue;
    }
    const { dependOn } = item;
    if (!dependOn) {
      continue;
    }
    if (typeof dependOn === "string") {
      chunks.unshift(dependOn);
    } else {
      chunks.unshift(...dependOn);
    }
  }
  return chunks;
}
const getTagConfig = (api) => {
  const config = api.getNormalizedConfig();
  const tags = (0, import_shared.castArray)(config.html.tags).filter(Boolean);
  if (!tags.length) {
    return void 0;
  }
  return {
    append: true,
    hash: false,
    publicPath: true,
    tags
  };
};
const pluginHtml = (modifyTagsFn) => ({
  name: "rsbuild:html",
  setup(api) {
    api.modifyBundlerChain(
      async (chain, { HtmlPlugin, isProd, CHAIN_ID, target }) => {
        const config = api.getNormalizedConfig();
        if ((0, import_shared.isHtmlDisabled)(config, target)) {
          return;
        }
        const minify = await (0, import_shared.getHtmlMinifyOptions)(isProd, config);
        const assetPrefix = (0, import_shared.getPublicPathFromChain)(chain, false);
        const entries = chain.entryPoints.entries() || {};
        const entryNames = Object.keys(entries);
        const htmlPaths = api.getHTMLPaths();
        const htmlInfoMap = {};
        const finalOptions = await Promise.all(
          entryNames.map(async (entryName) => {
            const entryValue = entries[entryName].values();
            const chunks = getChunks(
              entryName,
              // EntryDescription type is different between webpack and Rspack
              entryValue
            );
            const inject = getInject(entryName, config);
            const filename = htmlPaths[entryName];
            const { templatePath, templateContent } = await getTemplate(
              entryName,
              config,
              api.context.rootPath
            );
            const templateParameters = getTemplateParameters(
              entryName,
              config,
              assetPrefix
            );
            const metaTags = getMetaTags(entryName, config, templateContent);
            const pluginOptions = {
              meta: metaTags,
              chunks,
              inject,
              minify,
              filename,
              template: templatePath,
              entryName,
              templateParameters,
              scriptLoading: config.html.scriptLoading
            };
            if (chunks.length > 1) {
              pluginOptions.chunksSortMode = "manual";
            }
            const htmlInfo = {};
            htmlInfoMap[entryName] = htmlInfo;
            if (templateContent) {
              htmlInfo.templateContent = templateContent;
            }
            const tagConfig = getTagConfig(api);
            if (tagConfig) {
              htmlInfo.tagConfig = tagConfig;
            }
            pluginOptions.title = getTitle(entryName, config);
            const favicon = getFavicon(entryName, config);
            if (favicon) {
              if ((0, import_shared.isURL)(favicon)) {
                htmlInfo.favicon = favicon;
              } else {
                pluginOptions.favicon = favicon;
              }
            }
            const finalOptions2 = (0, import_shared.mergeChainedOptions)({
              defaults: pluginOptions,
              options: typeof config.tools.htmlPlugin === "boolean" ? {} : config.tools.htmlPlugin,
              utils: {
                entryName,
                entryValue
              }
            });
            return finalOptions2;
          })
        );
        entryNames.forEach((entryName, index) => {
          chain.plugin(`${CHAIN_ID.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [finalOptions[index]]);
        });
        const { HtmlBasicPlugin } = await Promise.resolve().then(() => __toESM(require("../rspack/HtmlBasicPlugin")));
        chain.plugin(CHAIN_ID.PLUGIN.HTML_BASIC).use(HtmlBasicPlugin, [htmlInfoMap, modifyTagsFn]);
        if (config.html) {
          const { appIcon, crossorigin } = config.html;
          if (crossorigin) {
            const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
            chain.output.crossOriginLoading(formattedCrossorigin);
          }
          if (appIcon) {
            const { HtmlAppIconPlugin } = await Promise.resolve().then(() => __toESM(require("../rspack/HtmlAppIconPlugin")));
            const distDir = (0, import_shared.getDistPath)(config, "image");
            const iconPath = import_node_path.default.isAbsolute(appIcon) ? appIcon : import_node_path.default.join(api.context.rootPath, appIcon);
            chain.plugin(CHAIN_ID.PLUGIN.APP_ICON).use(HtmlAppIconPlugin, [{ iconPath, distDir }]);
          }
        }
      }
    );
    api.onAfterCreateCompiler(({ compiler }) => {
      const { nonce } = api.getNormalizedConfig().security;
      if (!nonce) {
        return;
      }
      (0, import_shared.applyToCompiler)(compiler, (compiler2) => {
        const { plugins } = compiler2.options;
        const hasHTML = plugins.some(
          (plugin) => plugin && plugin.constructor.name === "HtmlBasicPlugin"
        );
        if (!hasHTML) {
          return;
        }
        const injectCode = (0, import_shared.createVirtualModule)(
          `__webpack_nonce__ = "${nonce}";`
        );
        new compiler2.webpack.EntryPlugin(compiler2.context, injectCode, {
          name: void 0
        }).apply(compiler2);
      });
    });
    api.modifyHTMLTags({
      // ensure `crossorigin` and `nonce` can be applied to all tags
      order: "post",
      handler: ({ headTags, bodyTags }) => {
        var _a;
        const config = api.getNormalizedConfig();
        const { crossorigin } = config.html;
        const { nonce } = config.security;
        const allTags = [...headTags, ...bodyTags];
        if (crossorigin) {
          const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
          for (const tag of allTags) {
            if (tag.tag === "script" && tag.attrs?.src || tag.tag === "link" && tag.attrs?.rel === "stylesheet") {
              tag.attrs || (tag.attrs = {});
              (_a = tag.attrs).crossorigin ?? (_a.crossorigin = formattedCrossorigin);
            }
          }
        }
        if (nonce) {
          for (const tag of allTags) {
            if (tag.tag === "script" || tag.tag === "style") {
              tag.attrs ?? (tag.attrs = {});
              tag.attrs.nonce = nonce;
            }
          }
        }
        return { headTags, bodyTags };
      }
    });
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getFavicon,
  getInject,
  getMetaTags,
  getTemplate,
  getTitle,
  pluginHtml
});
