import type { Compiler, MultiCompiler } from '@rspack/core';
import type { Compiler as WebpackCompiler, MultiCompiler as WebpackMultiCompiler } from 'webpack';
import deepmerge from '../compiled/deepmerge';
import color from '../compiled/picocolors';
import type { CacheGroups, CompilerTapFn, ModifyChainUtils, MultiStats, NodeEnv, NormalizedConfig, RsbuildTarget, SharedCompiledPkgNames, Stats } from './types';
export { color, deepmerge };
export type Colors = Omit<keyof typeof color, 'createColor' | 'isColorSupported'>;
export declare const getNodeEnv: () => NodeEnv;
export declare const setNodeEnv: (env: NodeEnv) => void;
export declare const isDev: () => boolean;
export declare const isProd: () => boolean;
export declare const isTest: () => boolean;
export declare const isString: (str: unknown) => str is string;
export declare const isUndefined: (obj: unknown) => obj is undefined;
export declare const isFunction: (func: unknown) => func is (...args: any[]) => any;
export declare const isObject: (obj: unknown) => obj is Record<string, any>;
export declare const isPlainObject: (obj: unknown) => obj is Record<string, any>;
export declare const isRegExp: (obj: any) => obj is RegExp;
export declare const isNil: (o: unknown) => o is null | undefined;
export declare const createVirtualModule: (content: string) => string;
export declare const removeLeadingSlash: (s: string) => string;
export declare const removeTailingSlash: (s: string) => string;
export declare const addTrailingSlash: (s: string) => string;
export interface AwaitableGetter<T> extends PromiseLike<T[]> {
    promises: Promise<T>[];
}
/**
 * Make Awaitable.
 */
export declare const awaitableGetter: <T>(promises: Promise<T>[]) => AwaitableGetter<T>;
export declare const getJsSourceMap: (config: NormalizedConfig) => false | "eval" | "cheap-source-map" | "cheap-module-source-map" | "source-map" | "inline-cheap-source-map" | "inline-cheap-module-source-map" | "inline-source-map" | "inline-nosources-cheap-source-map" | "inline-nosources-cheap-module-source-map" | "inline-nosources-source-map" | "nosources-cheap-source-map" | "nosources-cheap-module-source-map" | "nosources-source-map" | "hidden-nosources-cheap-source-map" | "hidden-nosources-cheap-module-source-map" | "hidden-nosources-source-map" | "hidden-cheap-source-map" | "hidden-cheap-module-source-map" | "hidden-source-map" | "eval-cheap-source-map" | "eval-cheap-module-source-map" | "eval-source-map" | "eval-nosources-cheap-source-map" | "eval-nosources-cheap-module-source-map" | "eval-nosources-source-map";
export declare const getSharedPkgCompiledPath: (packageName: SharedCompiledPkgNames) => string;
export declare const isURL: (str: string) => boolean;
export declare function isWebTarget(target: RsbuildTarget | RsbuildTarget[]): boolean;
export declare function isServerTarget(target: RsbuildTarget[]): boolean;
export declare function resolvePackage(loader: string, dirname: string): string;
export declare const getCoreJsVersion: (corejsPkgPath: string) => string;
/**
 * ensure absolute file path.
 * @param base - Base path to resolve relative from.
 * @param filePath - Absolute or relative file path.
 * @returns Resolved absolute file path.
 */
export declare const ensureAbsolutePath: (base: string, filePath: string) => string;
export declare const castArray: <T>(arr?: T | T[]) => T[];
export declare const camelCase: (input: string) => string;
export declare const kebabCase: (str: string) => string;
export declare const cloneDeep: <T>(value: T) => T;
/** Expect to match path just like "./node_modules/react-router/" */
export declare const createDependenciesRegExp: (...dependencies: (string | RegExp)[]) => RegExp;
export declare function createCacheGroups(group: Record<string, (string | RegExp)[]>): CacheGroups;
export declare function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void;
export declare const upperFirst: (str: string) => string;
export declare const generateScriptTag: () => {
    tagName: string;
    attributes: {
        type: string;
    };
    voidTag: boolean;
    meta: {};
};
export declare const getPublicPathFromCompiler: (compiler: Compiler) => string;
export declare function partition<T>(array: T[], predicate: (value: T) => boolean): [T[], T[]];
export declare function pick<T, U extends keyof T>(obj: T, keys: ReadonlyArray<U>): Pick<T, U>;
export declare const prettyTime: (seconds: number) => string;
export declare const getProgressColor: (index: number) => Colors;
export declare const isHtmlDisabled: (config: NormalizedConfig, target: RsbuildTarget) => boolean;
export declare function isUsingHMR(config: NormalizedConfig, { isProd, target }: Pick<ModifyChainUtils, 'isProd' | 'target'>): boolean;
export declare const isClientCompiler: (compiler: {
    options: {
        target?: Compiler['options']['target'];
    };
}) => boolean;
type ServerCallbacks = {
    onInvalid: () => void;
    onDone: (stats: any) => void;
};
export declare const setupServerHooks: (compiler: {
    options: {
        target?: Compiler['options']['target'];
    };
    hooks: {
        compile: CompilerTapFn<ServerCallbacks['onInvalid']>;
        invalid: CompilerTapFn<ServerCallbacks['onInvalid']>;
        done: CompilerTapFn<ServerCallbacks['onDone']>;
    };
}, hookCallbacks: ServerCallbacks) => void;
export declare const isMultiCompiler: <C extends Compiler | WebpackCompiler = Compiler, M extends MultiCompiler | WebpackMultiCompiler = MultiCompiler>(compiler: C | M) => compiler is M;
export declare const applyToCompiler: (compiler: Compiler | MultiCompiler, apply: (c: Compiler) => void) => void;
export declare const onCompileDone: (compiler: Compiler | MultiCompiler, onDone: (stats: Stats | MultiStats) => Promise<void>, MultiStatsCtor: new (stats: Stats[]) => MultiStats) => void;
